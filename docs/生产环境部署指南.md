# 生产环境部署指南

**版本**: v1.0.0-mvp
**更新日期**: 2025-10-28
**适用系统**: Linux (Ubuntu 20.04+, CentOS 7+, Debian 10+)

---

## 📋 目录

1. [环境准备](#环境准备)
2. [清理旧环境](#清理旧环境)
3. [部署新环境](#部署新环境)
   - [在线部署](#在线部署-推荐)
   - [离线部署](#离线部署-适用于阿里云等网络受限环境)
4. [配置说明](#配置说明)
5. [启动服务](#启动服务)
6. [验证部署](#验证部署)
7. [常见问题](#常见问题)
8. [维护管理](#维护管理)

---

## 环境准备

### 系统要求

- **操作系统**: Linux (推荐 Ubuntu 20.04+ 或 CentOS 7+)
- **CPU**: 2核心以上
- **内存**: 4GB以上 (推荐8GB)
- **磁盘**: 20GB以上可用空间
- **网络**: 公网IP或域名

### 必需软件

1. **Docker** (版本 20.10+)
2. **Docker Compose** (版本 2.0+)
3. **Git**
4. **OpenSSL** (用于生成密钥)

### 安装Docker和Docker Compose

```bash
# Ubuntu/Debian
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
sudo usermod -aG docker $USER

# 安装 Docker Compose
sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

# 验证安装
docker --version
docker-compose --version
```

### 端口要求

确保以下端口开放:

- **80**: HTTP访问 (前端)
- **443**: HTTPS访问 (如使用SSL)
- **8000**: 后端API (可选,如需外部访问)
- **5432**: PostgreSQL (内部使用,不建议对外开放)
- **6379**: Redis (内部使用,不建议对外开放)

---

## 清理旧环境

如果服务器上已有旧的部署,需要先清理。

### 方法1: 使用清理脚本 (推荐)

```bash
# 创建清理脚本
cat > /tmp/cleanup_production.sh << 'CLEANUP_EOF'
#!/bin/bash
# =============================================================================
# 生产服务器完全清理脚本
# =============================================================================
# 警告：此脚本会删除所有Docker容器、镜像、卷和项目文件
# 使用前请确认已备份重要数据！
# =============================================================================

set -e

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}========================================"
echo -e "  生产服务器清理脚本"
echo -e "========================================${NC}"
echo ""

# 确认操作
echo -e "${RED}警告：此操作将删除以下内容：${NC}"
echo "  1. 所有Docker容器（包括运行中的）"
echo "  2. 所有Docker镜像"
echo "  3. 所有Docker卷（包括数据库数据）"
echo "  4. 所有Docker网络"
echo "  5. 项目源代码目录"
echo ""
echo -e "${YELLOW}建议：在继续前先备份数据库${NC}"
echo ""
read -p "确定要继续吗？输入 YES 确认：" confirm

if [ "$confirm" != "YES" ]; then
    echo -e "${GREEN}操作已取消${NC}"
    exit 0
fi

echo ""
echo -e "${YELLOW}开始清理...${NC}"
echo ""

# 1. 停止所有容器
echo -e "${BLUE}[1/7] 停止所有Docker容器...${NC}"
if [ "$(docker ps -q)" ]; then
    docker stop $(docker ps -q)
    echo -e "${GREEN}✓ 已停止所有容器${NC}"
else
    echo -e "${YELLOW}没有运行中的容器${NC}"
fi

# 2. 删除所有容器
echo -e "${BLUE}[2/7] 删除所有Docker容器...${NC}"
if [ "$(docker ps -aq)" ]; then
    docker rm -f $(docker ps -aq)
    echo -e "${GREEN}✓ 已删除所有容器${NC}"
else
    echo -e "${YELLOW}没有容器需要删除${NC}"
fi

# 3. 删除所有镜像
echo -e "${BLUE}[3/7] 删除所有Docker镜像...${NC}"
if [ "$(docker images -q)" ]; then
    docker rmi -f $(docker images -q)
    echo -e "${GREEN}✓ 已删除所有镜像${NC}"
else
    echo -e "${YELLOW}没有镜像需要删除${NC}"
fi

# 4. 删除所有卷
echo -e "${BLUE}[4/7] 删除所有Docker卷...${NC}"
if [ "$(docker volume ls -q)" ]; then
    docker volume rm -f $(docker volume ls -q)
    echo -e "${GREEN}✓ 已删除所有卷${NC}"
else
    echo -e "${YELLOW}没有卷需要删除${NC}"
fi

# 5. 删除所有网络（保留默认网络）
echo -e "${BLUE}[5/7] 删除所有自定义Docker网络...${NC}"
if [ "$(docker network ls -q -f type=custom)" ]; then
    docker network rm $(docker network ls -q -f type=custom) 2>/dev/null || true
    echo -e "${GREEN}✓ 已删除所有自定义网络${NC}"
else
    echo -e "${YELLOW}没有自定义网络需要删除${NC}"
fi

# 6. 清理Docker系统
echo -e "${BLUE}[6/7] 清理Docker系统缓存...${NC}"
docker system prune -af --volumes
echo -e "${GREEN}✓ 已清理Docker系统${NC}"

# 7. 删除项目代码目录
echo -e "${BLUE}[7/7] 删除项目代码目录...${NC}"
if [ -d "$HOME/mr_gunking_user_system_spec" ]; then
    rm -rf "$HOME/mr_gunking_user_system_spec"
    echo -e "${GREEN}✓ 已删除 ~/mr_gunking_user_system_spec${NC}"
fi

if [ -d "/opt/mr_gunking_user_system_spec" ]; then
    sudo rm -rf "/opt/mr_gunking_user_system_spec"
    echo -e "${GREEN}✓ 已删除 /opt/mr_gunking_user_system_spec${NC}"
fi

# 查找并删除所有可能的项目目录
echo -e "${YELLOW}查找其他可能的项目目录...${NC}"
find ~ -maxdepth 2 -name "mr_gunking_user_system_spec" -type d 2>/dev/null | while read dir; do
    echo -e "${YELLOW}找到: $dir${NC}"
    read -p "是否删除 $dir? (y/n): " del_confirm
    if [ "$del_confirm" = "y" ]; then
        rm -rf "$dir"
        echo -e "${GREEN}✓ 已删除 $dir${NC}"
    fi
done

echo ""
echo -e "${BLUE}========================================"
echo -e "  清理完成！"
echo -e "========================================${NC}"
echo ""
echo -e "${GREEN}已清理内容：${NC}"
echo "  ✓ Docker容器"
echo "  ✓ Docker镜像"
echo "  ✓ Docker卷（包括数据）"
echo "  ✓ Docker网络"
echo "  ✓ 项目源代码"
echo ""
echo -e "${YELLOW}验证清理结果：${NC}"
echo "  docker ps -a        # 应该为空"
echo "  docker images       # 应该为空"
echo "  docker volume ls    # 应该为空"
echo "  docker network ls   # 只有默认网络"
echo ""
echo -e "${GREEN}服务器已清理干净，可以重新部署！${NC}"
echo ""
CLEANUP_EOF

# 赋予执行权限
chmod +x /tmp/cleanup_production.sh

# 执行清理脚本
/tmp/cleanup_production.sh
```

### 方法2: 手动清理

```bash
# 停止并删除所有容器
docker stop $(docker ps -aq)
docker rm -f $(docker ps -aq)

# 删除所有镜像
docker rmi -f $(docker images -q)

# 删除所有卷
docker volume rm -f $(docker volume ls -q)

# 删除自定义网络
docker network prune -f

# 清理系统
docker system prune -af --volumes

# 删除项目目录
sudo rm -rf /opt/mr_gunking_user_system_spec
```

### 验证清理结果

```bash
docker ps -a        # 应该为空
docker images       # 应该为空
docker volume ls    # 应该为空
docker network ls   # 只有默认网络 (bridge, host, none)
```

---

## 部署新环境

### 1. 克隆代码

**推荐位置**: `/opt/mr_gunking_user_system_spec`

```bash
# 进入/opt目录
cd /opt

# 克隆代码
git clone https://github.com/liangzh77/mr_gunking_user_system_spec.git

# 进入项目目录
cd mr_gunking_user_system_spec

# 切换到MVP版本
git checkout v1.0.0-mvp

# 设置权限
chown -R root:root /opt/mr_gunking_user_system_spec
chmod -R 755 /opt/mr_gunking_user_system_spec
```

### 2. 配置环境变量

#### 方法A: 使用自动配置脚本 (推荐)

```bash
cd /opt/mr_gunking_user_system_spec

# 创建自动配置脚本
cat > configure_env.sh << 'EOF'
#!/bin/bash
set -e

echo "=========================================="
echo "  生产环境配置生成器"
echo "=========================================="
echo ""

# 生成随机密钥
echo "正在生成安全密钥..."
DB_PASSWORD=$(openssl rand -base64 24 | tr -d '/+=' | head -c 32)
REDIS_PASSWORD=$(openssl rand -base64 18 | tr -d '/+=' | head -c 24)
SECRET_KEY=$(openssl rand -hex 32)
JWT_SECRET_KEY=$(openssl rand -hex 32)
ENCRYPTION_KEY=$(openssl rand -base64 32)

echo "✓ 密钥生成完成"
echo ""

# 询问服务器信息
read -p "请输入服务器IP地址或域名: " SERVER_HOST
read -p "是否使用HTTPS? (y/n, 默认n): " USE_HTTPS
USE_HTTPS=${USE_HTTPS:-n}

if [ "$USE_HTTPS" = "y" ]; then
    PROTOCOL="https"
else
    PROTOCOL="http"
fi

# 生成配置文件
echo "正在生成 .env.production ..."

cp .env.production.template .env.production

# 替换密钥
sed -i "s|DB_PASSWORD=CHANGE_THIS_TO_STRONG_PASSWORD_32CHARS|DB_PASSWORD=$DB_PASSWORD|g" .env.production
sed -i "s|REDIS_PASSWORD=CHANGE_THIS_TO_STRONG_REDIS_PASSWORD|REDIS_PASSWORD=$REDIS_PASSWORD|g" .env.production
sed -i "s|SECRET_KEY=CHANGE_THIS_TO_RANDOM_SECRET_KEY_64_CHARS|SECRET_KEY=$SECRET_KEY|g" .env.production
sed -i "s|JWT_SECRET_KEY=CHANGE_THIS_TO_RANDOM_JWT_SECRET_KEY_64_CHARS|JWT_SECRET_KEY=$JWT_SECRET_KEY|g" .env.production
sed -i "s|ENCRYPTION_KEY=CHANGE_THIS_TO_32_BYTES_ENCRYPTION_KEY|ENCRYPTION_KEY=$ENCRYPTION_KEY|g" .env.production

# 更新DATABASE_URL
sed -i "s|postgresql+asyncpg://mr_admin:CHANGE_THIS_TO_STRONG_PASSWORD_32CHARS@|postgresql+asyncpg://mr_admin:$DB_PASSWORD@|g" .env.production
sed -i "s|redis://:CHANGE_THIS_TO_STRONG_REDIS_PASSWORD@|redis://:$REDIS_PASSWORD@|g" .env.production

# 更新域名/IP
sed -i "s|BACKEND_CORS_ORIGINS=https://yourdomain.com,https://www.yourdomain.com|BACKEND_CORS_ORIGINS=$PROTOCOL://$SERVER_HOST,$PROTOCOL://www.$SERVER_HOST|g" .env.production
sed -i "s|VITE_API_BASE_URL=https://yourdomain.com/api/v1|VITE_API_BASE_URL=$PROTOCOL://$SERVER_HOST/api/v1|g" .env.production

echo "✓ 配置文件生成完成"
echo ""

# 保存密钥到文件
CREDENTIALS_FILE="production_credentials_$(date +%Y%m%d_%H%M%S).txt"
cat > "$CREDENTIALS_FILE" << CRED_EOF
========================================
  MR游戏运营管理系统 - 生产环境凭据
========================================
生成时间: $(date)
服务器: $PROTOCOL://$SERVER_HOST

数据库凭据:
-----------
用户名: mr_admin
密码: $DB_PASSWORD

Redis凭据:
-----------
密码: $REDIS_PASSWORD

应用密钥:
-----------
SECRET_KEY: $SECRET_KEY
JWT_SECRET_KEY: $JWT_SECRET_KEY
ENCRYPTION_KEY: $ENCRYPTION_KEY

========================================
⚠️ 重要提示:
1. 请妥善保管此文件
2. 不要将此文件上传到版本控制系统
3. 建议将此文件保存到安全的密码管理器
4. 配置完成后可删除此文件
========================================
CRED_EOF

chmod 600 "$CREDENTIALS_FILE"

echo "=========================================="
echo "  配置摘要"
echo "=========================================="
echo "服务器地址: $PROTOCOL://$SERVER_HOST"
echo "配置文件: .env.production"
echo "凭据文件: $CREDENTIALS_FILE"
echo ""
echo "⚠️ 重要: 凭据已保存到 $CREDENTIALS_FILE"
echo "   请妥善保管此文件！"
echo ""
EOF

chmod +x configure_env.sh

# 执行配置脚本
./configure_env.sh
```

#### 方法B: 手动配置

```bash
cd /opt/mr_gunking_user_system_spec

# 1. 生成密钥
DB_PASSWORD=$(openssl rand -base64 24 | tr -d '/+=' | head -c 32)
REDIS_PASSWORD=$(openssl rand -base64 18 | tr -d '/+=' | head -c 24)
SECRET_KEY=$(openssl rand -hex 32)
JWT_SECRET_KEY=$(openssl rand -hex 32)
ENCRYPTION_KEY=$(openssl rand -base64 32)

# 2. 显示生成的密钥（请保存）
echo "数据库密码: $DB_PASSWORD"
echo "Redis密码: $REDIS_PASSWORD"
echo "SECRET_KEY: $SECRET_KEY"
echo "JWT_SECRET_KEY: $JWT_SECRET_KEY"
echo "ENCRYPTION_KEY: $ENCRYPTION_KEY"

# 3. 复制模板文件
cp .env.production.template .env.production

# 4. 编辑配置文件
nano .env.production
```

**手动编辑时需要修改的内容**:

```bash
# 数据库配置
DB_PASSWORD=<粘贴上面生成的DB_PASSWORD>
DATABASE_URL=postgresql+asyncpg://mr_admin:<DB_PASSWORD>@postgres:5432/mr_game_ops

# Redis配置
REDIS_PASSWORD=<粘贴上面生成的REDIS_PASSWORD>
REDIS_URL=redis://:<REDIS_PASSWORD>@redis:6379/0

# 安全配置
SECRET_KEY=<粘贴上面生成的SECRET_KEY>
JWT_SECRET_KEY=<粘贴上面生成的JWT_SECRET_KEY>
ENCRYPTION_KEY=<粘贴上面生成的ENCRYPTION_KEY>

# CORS配置（修改为实际域名或IP）
BACKEND_CORS_ORIGINS=http://你的服务器IP,http://www.你的服务器IP

# 前端API地址（修改为实际域名或IP）
VITE_API_BASE_URL=http://你的服务器IP/api/v1
```

---

## 配置说明

### 核心配置项

| 配置项 | 说明 | 示例值 | 是否必改 |
|--------|------|--------|----------|
| `DB_PASSWORD` | 数据库密码 | 随机生成的32字符密码 | ✅ 是 |
| `REDIS_PASSWORD` | Redis密码 | 随机生成的24字符密码 | ✅ 是 |
| `SECRET_KEY` | 应用密钥 | 64字符十六进制 | ✅ 是 |
| `JWT_SECRET_KEY` | JWT密钥 | 64字符十六进制 | ✅ 是 |
| `ENCRYPTION_KEY` | 加密密钥 | 32字节base64 | ✅ 是 |
| `BACKEND_CORS_ORIGINS` | 允许的前端域名 | `http://192.168.1.100` | ✅ 是 |
| `VITE_API_BASE_URL` | 前端API地址 | `http://192.168.1.100/api/v1` | ✅ 是 |
| `DEBUG` | 调试模式 | `false` | ❌ 保持 |
| `ENVIRONMENT` | 环境标识 | `production` | ❌ 保持 |
| `LOG_LEVEL` | 日志级别 | `WARNING` | ❌ 保持 |

### 可选配置项

**支付平台配置** (如暂时不需要支付功能,可留空):

```bash
WECHAT_PAY_APP_ID=
WECHAT_PAY_MCH_ID=
WECHAT_PAY_API_KEY=

ALIPAY_APP_ID=
ALIPAY_PRIVATE_KEY=
ALIPAY_PUBLIC_KEY=
```

---

## 启动服务

### 使用生产环境配置启动

```bash
cd /opt/mr_gunking_user_system_spec

# 启动所有服务
docker-compose -f docker-compose.prod.yml up -d --build
```

### 查看启动日志

```bash
# 查看所有服务日志
docker-compose -f docker-compose.prod.yml logs -f

# 查看特定服务日志
docker-compose -f docker-compose.prod.yml logs -f backend
docker-compose -f docker-compose.prod.yml logs -f frontend
docker-compose -f docker-compose.prod.yml logs -f postgres
```

### 查看容器状态

```bash
docker-compose -f docker-compose.prod.yml ps
```

预期输出:
```
NAME                        STATUS         PORTS
mr_game_ops_backend        Up (healthy)   0.0.0.0:8000->8000/tcp
mr_game_ops_db             Up (healthy)   0.0.0.0:5432->5432/tcp
mr_game_ops_frontend       Up             0.0.0.0:80->80/tcp
mr_game_ops_redis          Up (healthy)   0.0.0.0:6379->6379/tcp
mr_game_ops_pgadmin        Up             0.0.0.0:5050->80/tcp
mr_game_ops_redis_commander Up (healthy)  0.0.0.0:8081->8081/tcp
```

---

## 验证部署

### 1. 健康检查

```bash
# 检查后端健康状态
curl http://localhost:8000/health

# 预期输出
{"status":"healthy","version":"1.0.0","environment":"production"}
```

### 2. 访问前端

在浏览器中访问:
```
http://你的服务器IP
```

### 3. 访问API文档

```
http://你的服务器IP:8000/docs
```

### 4. 数据库连接测试

```bash
# 进入数据库容器
docker exec -it mr_game_ops_db psql -U mr_admin -d mr_game_ops

# 查看表
\dt

# 退出
\q
```

### 5. Redis连接测试

```bash
# 进入Redis容器
docker exec -it mr_game_ops_redis redis-cli -a 你的REDIS_PASSWORD

# 测试
PING
# 预期输出: PONG

# 退出
exit
```

---

## 常见问题

### Q1: 容器启动失败

**症状**: `docker-compose ps` 显示容器状态为 `Exit` 或 `Restarting`

**解决方法**:
```bash
# 查看错误日志
docker-compose -f docker-compose.prod.yml logs backend
docker-compose -f docker-compose.prod.yml logs postgres

# 常见原因:
# 1. 数据库密码配置不一致
# 2. 端口被占用
# 3. 内存不足
```

### Q2: 数据库连接失败

**症状**: 后端日志显示 `could not connect to server`

**解决方法**:
```bash
# 检查数据库密码是否一致
grep DB_PASSWORD .env.production
grep DATABASE_URL .env.production

# 确保两处密码一致
```

### Q3: CORS错误

**症状**: 前端访问API时报CORS错误

**解决方法**:
```bash
# 检查CORS配置
grep BACKEND_CORS_ORIGINS .env.production

# 确保包含前端访问地址
# 例如: BACKEND_CORS_ORIGINS=http://192.168.1.100,http://localhost
```

### Q4: 前端无法连接后端

**症状**: 前端页面加载正常,但API请求失败

**解决方法**:
```bash
# 检查前端API配置
grep VITE_API_BASE_URL .env.production

# 确保地址正确
# 例如: VITE_API_BASE_URL=http://192.168.1.100/api/v1

# 重新构建前端
docker-compose -f docker-compose.prod.yml up -d --build frontend
```

### Q5: 端口被占用

**症状**: `Error: Bind for 0.0.0.0:80 failed: port is already allocated`

**解决方法**:
```bash
# 查看端口占用
sudo netstat -tlnp | grep :80

# 停止占用端口的服务
sudo systemctl stop nginx  # 如果是nginx
sudo systemctl stop apache2  # 如果是apache

# 或修改docker-compose.prod.yml中的端口映射
```

---

## 维护管理

### 日常管理命令

```bash
# 查看服务状态
docker-compose -f docker-compose.prod.yml ps

# 重启所有服务
docker-compose -f docker-compose.prod.yml restart

# 重启单个服务
docker-compose -f docker-compose.prod.yml restart backend

# 停止所有服务
docker-compose -f docker-compose.prod.yml stop

# 启动所有服务
docker-compose -f docker-compose.prod.yml start

# 完全停止并删除容器
docker-compose -f docker-compose.prod.yml down

# 停止并删除所有数据(包括数据库)
docker-compose -f docker-compose.prod.yml down -v
```

### 日志管理

```bash
# 查看最新100行日志
docker-compose -f docker-compose.prod.yml logs --tail=100

# 实时查看日志
docker-compose -f docker-compose.prod.yml logs -f

# 查看特定时间的日志
docker-compose -f docker-compose.prod.yml logs --since 2025-10-28T10:00:00
```

### 数据库备份

```bash
# 创建备份目录
mkdir -p /opt/backups

# 备份数据库
docker exec mr_game_ops_db pg_dump -U mr_admin mr_game_ops > /opt/backups/backup_$(date +%Y%m%d_%H%M%S).sql

# 自动备份脚本
cat > /opt/backup_db.sh << 'BACKUP_EOF'
#!/bin/bash
BACKUP_DIR="/opt/backups"
RETENTION_DAYS=7

# 创建备份
docker exec mr_game_ops_db pg_dump -U mr_admin mr_game_ops | gzip > "$BACKUP_DIR/backup_$(date +%Y%m%d_%H%M%S).sql.gz"

# 删除旧备份
find "$BACKUP_DIR" -name "backup_*.sql.gz" -mtime +$RETENTION_DAYS -delete

echo "Backup completed: $(date)"
BACKUP_EOF

chmod +x /opt/backup_db.sh

# 添加到crontab (每天凌晨2点备份)
(crontab -l 2>/dev/null; echo "0 2 * * * /opt/backup_db.sh >> /var/log/db_backup.log 2>&1") | crontab -
```

### 数据库恢复

```bash
# 从备份恢复
gunzip < /opt/backups/backup_20251028_020000.sql.gz | docker exec -i mr_game_ops_db psql -U mr_admin -d mr_game_ops
```

### 更新部署

```bash
cd /opt/mr_gunking_user_system_spec

# 拉取最新代码
git pull origin main

# 切换到新版本
git checkout v1.0.1

# 重新构建并启动
docker-compose -f docker-compose.prod.yml up -d --build

# 查看启动状态
docker-compose -f docker-compose.prod.yml logs -f
```

### 资源监控

```bash
# 查看容器资源使用
docker stats

# 查看磁盘使用
docker system df

# 清理未使用的资源
docker system prune -a
```

---

## 安全建议

### 1. 防火墙配置

```bash
# Ubuntu/Debian
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw enable

# CentOS/RHEL
sudo firewall-cmd --permanent --add-service=http
sudo firewall-cmd --permanent --add-service=https
sudo firewall-cmd --reload
```

### 2. SSL/TLS配置

推荐使用 Let's Encrypt 免费证书:

```bash
# 安装 certbot
sudo apt-get install certbot

# 获取证书
sudo certbot certonly --standalone -d yourdomain.com

# 证书位置
# /etc/letsencrypt/live/yourdomain.com/fullchain.pem
# /etc/letsencrypt/live/yourdomain.com/privkey.pem

# 自动续期
sudo certbot renew --dry-run
```

### 3. 密码管理

- 定期更换数据库和Redis密码
- 使用强密码(至少32字符,包含大小写字母、数字、特殊字符)
- 不要在日志中记录密码
- 使用环境变量而不是硬编码

### 4. 访问控制

```bash
# 限制数据库和Redis仅内部访问
# 在 docker-compose.prod.yml 中移除端口映射
# 或使用防火墙规则限制外部访问
```

---

## 附录

### A. 目录结构

```
/opt/mr_gunking_user_system_spec/
├── backend/                # 后端代码
├── frontend/              # 前端代码
├── docker-compose.prod.yml # 生产环境Docker配置
├── .env.production        # 生产环境变量(不提交到Git)
├── .env.production.template # 环境变量模板
└── configure_env.sh       # 自动配置脚本
```

### B. 环境变量完整列表

参考 `.env.production.template` 文件中的详细说明。

### C. API端点

| 端点 | 说明 |
|------|------|
| `/health` | 健康检查 |
| `/api/v1/docs` | API文档 |
| `/api/v1/admins/*` | 管理员API |
| `/api/v1/finance/*` | 财务API |
| `/api/v1/operators/*` | 运营商API |

### D. 联系支持

如遇到问题,请访问:
- GitHub Issues: https://github.com/liangzh77/mr_gunking_user_system_spec/issues
- 项目文档: https://github.com/liangzh77/mr_gunking_user_system_spec/tree/main/docs

---

**文档版本**: 1.0.0
**最后更新**: 2025-10-28
**维护者**: liangzh77
